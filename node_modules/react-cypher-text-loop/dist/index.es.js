import PropTypes from 'prop-types';
import React, { useState, useEffect } from 'react';

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var CypherText = function CypherText(_ref) {
  var textList = _ref.textList,
      delay = _ref.delay,
      props = objectWithoutProperties(_ref, ['textList', 'delay']);

  var _useState = useState(''),
      _useState2 = slicedToArray(_useState, 2),
      CypherText = _useState2[0],
      setCypherText = _useState2[1];

  var placeholderChars = '________-_\\/[]{}â€”=+*^?#!<>';

  var textIndex = 0;
  var queue = [];

  var frameRequest = void 0;
  var frame = void 0;
  var resolvePromise = void 0;

  var setText = function setText(newText) {
    var oldText = textList[textIndex === 0 ? textList.length - 1 : textIndex - 1];
    var length = Math.max(oldText.length, newText.length);
    var promise = new Promise(function (resolve) {
      return resolvePromise = resolve;
    });
    queue = [];
    for (var i = 0; i < length; i++) {
      var from = oldText[i] || '';
      var to = newText[i] || '';
      var start = Math.floor(Math.random() * 40);
      var end = start + Math.floor(Math.random() * 40);
      queue.push({ from: from, to: to, start: start, end: end });
    }
    window.cancelAnimationFrame(frameRequest);
    frame = 0;
    update();
    return promise;
  };

  var update = function update() {
    var complete = 0;

    var output = queue.map(function (item, i) {
      var from = item.from,
          to = item.to,
          start = item.start,
          end = item.end,
          char = item.char;

      if (frame >= end) {
        complete++;
        return React.createElement(
          React.Fragment,
          { key: i },
          to
        );
      } else if (frame >= start) {
        if (!char || Math.random() < 0.28) {
          char = randomChar(placeholderChars);
          item.char = char;
        }
        return React.createElement(
          'span',
          { key: i, style: { color: '#909090' } },
          char
        );
      } else {
        return React.createElement(
          React.Fragment,
          { key: i },
          from
        );
      }
    });

    setCypherText(output);

    if (complete === queue.length) {
      resolvePromise();
    } else {
      frameRequest = window.requestAnimationFrame(update);
      frame++;
    }
  };

  var randomChar = function randomChar(string) {
    return string[Math.floor(Math.random() * string.length)];
  };

  var next = function next() {
    setText(textList[textIndex]).then(function () {
      setTimeout(next, delay);
    });

    textIndex = (textIndex + 1) % textList.length;
  };

  useEffect(function () {
    next();
    return function () {
      clearTimeout(next);
      window.cancelAnimationFrame(frameRequest);
    };
  }, []);

  return React.createElement(
    'div',
    props,
    CypherText
  );
};

CypherText.propTypes = {
  textList: PropTypes.array.isRequired,
  delay: PropTypes.number,
  randomOrder: PropTypes.bool
};

CypherText.defaultProps = {
  delay: 800
};

export default CypherText;
//# sourceMappingURL=index.es.js.map
