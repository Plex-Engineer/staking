import { Tab, Tabs, TabList, TabPanel } from "react-tabs";
import styled from "styled-components";
import DexField from "../dex/dexField";
import { useEffect, useState } from "react";
import { useEnableToken } from "hooks/useTransaction";
import { useToken } from "providers/activeTokenContext";
import { BigNumber, utils } from "ethers";
import { Details, TrasanctionType } from "./BorrowLimits";

import {
  useSupply,
  useBorrow,
  useReedem,
  useRepay,
} from "hooks/useTransaction";
import { formatBalance, toWei } from "utils";
import { TransactionStatus,  } from "@usedapp/core";

//ENUM
enum InputState {
  ENABLE,
  NOFUNDS,
  ENTERAMOUNT,
  CONFIRM,
  INVALID,
}

//STYLING
const Container = styled.div`
  display: flex;
  height: 90vh;
  width: 400px;
  flex-direction: column;
  align-items: stretch;
  .title {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1rem;
    margin: 1rem;
  }
  .tabs {
    margin: 16px;
  }

  .tablist {
    list-style: none;
    display: flex;
    justify-content: space-between;
    border-bottom: 1px solid var(--primary-color);
    padding: 0;
    color: #efefef;
    font-weight: 400;
    .tab {
      flex: 1;
      cursor: pointer;
      padding: 0.5rem;
      text-align: center;
      transition: all 0.2s ease-in-out;
      &:hover:not(.selected) {
        background: #a7efd218;
      }
      &:focus {
        outline: none;
      }
    }
  }

  .selected {
    background: rgba(6, 252, 153, 0.15);
    border-radius: 1px;
    color: var(--primary-color);
  }

  @media (max-width: 1000px) {
    width: 100vw;
  }
`;

const Button = styled.button`
  font-weight: 300;
  font-size: 18px;
  background-color: black;
  color: var(--primary-color);
  padding: 0.2rem 2rem;
  border: 1px solid var(--primary-color);
  margin: 3rem auto;
  margin-bottom: 0;
  display: flex;
  align-self: center;
  &:hover {
    background-color: var(--primary-color-dark);
    color: black;
    cursor: pointer;
  }
`;

const DisabledButton = styled.button`
  font-weight: 300;
  font-size: 18px;
  background-color: black;
  color: #939393;
  padding: 0.2rem 2rem;
  border: 1px solid #939393;
  margin: 3rem auto;
  margin-bottom: 0;
  display: flex;
  align-self: center;
`;

export const Wallet = styled.div`
  display: flex;
  justify-content: space-between;
  margin: 2rem 0 1.3rem 0;
  border-top: 1px solid #222;
  padding-top: 1rem;
  p:first-child {
    font-weight: 300;
    font-size: 16px;
    color: #dfdfdf;
  }
  p:last-child {
    font-weight: 300;
    font-size: 16px;
    color: var(--primary-color);
  }
`;

//INTERFACES
interface ILendingModal {
  isBorrow: boolean;
}

interface IButton {
  state: InputState;
  token: any;
  amount: string;
  transactionType: TrasanctionType;
  transaction : TransactionStatus | undefined;
}

const ReactiveButton = ({ state, token, amount, transactionType }: IButton) => {
  let transaction :TransactionStatus | undefined;
  useEffect(
    () => {
    },[transaction?.status]
  )

  const { state: supplyState, send: supplySend } = useSupply(
    token.data.address
  );
  const { state: borrowState, send: borrowSend } = useBorrow(
    token.data.address
  );
  const { state: repayState, send: repaySend } = useRepay(token.data.address);
  const { state: redeemState, send: redeemSend } = useReedem(
    token.data.address
  );
  const { state: transactionStatus, send } = useEnableToken(
    token.data.underlying_address
  );

  function showText() {
    switch (transactionType) {
      case TrasanctionType.SUPPLY:
        return "Supply";
      case TrasanctionType.BORROW:
        return "Borrow";
      case TrasanctionType.REPAY:
        return "Repay";
      case TrasanctionType.WITHDRAW:
        return "Withdraw";
    }
  }
  useEffect(
    ()=>{
      console.log(amount)
    },[amount]
  )
  switch (state) {
    case InputState.ENABLE:
      return (
        <Button
          onClick={() => {
            console.log(transactionStatus);
            
            send(
              token.wallet,
              BigNumber.from(
                "115792089237316195423570985008687907853269984665640564039457584007913129639935"
              )
            );
          }}
        >
          {" "}
          enable{" "}
        </Button>
      );
    case InputState.ENTERAMOUNT:
      return <DisabledButton> enter amount </DisabledButton>;
    case InputState.CONFIRM:
      return (
        <Button
          onClick={() => {
            console.log(toWei(amount,token.data.underlying_decimals).toString())
            switch (transactionType) {
              case TrasanctionType.SUPPLY:
                transaction = supplyState;
                supplySend(
                  toWei(amount,token.data.underlying_decimals).toString()
                );
                break;
              case TrasanctionType.BORROW:
                    transaction = borrowState;
                borrowSend(
                  toWei(amount,token.data.underlying_decimals).toString()
                );
                break;
              case TrasanctionType.REPAY:
                transaction = repayState;
                repaySend(
                  toWei(amount,token.data.underlying_decimals).toString()
                );
                break;
              case TrasanctionType.WITHDRAW:
                transaction = redeemState;
                redeemSend(
                  toWei(amount,token.data.underlying_decimals).toString()
                );
            }
          }}
        >
          {" "}
          <div>
            {supplyState.status}
            {showText()}
          </div>{" "}
        </Button>
      );
    case InputState.NOFUNDS:
      return <DisabledButton> no funds </DisabledButton>;
    case InputState.INVALID:
      return <DisabledButton> enter valid value</DisabledButton>;
    default:
      return <Button> enable </Button>;
  }
};
const LendingModal = (props: ILendingModal) => {
  const tokenState = useToken();
  const token = tokenState[0].token;
  const stats = tokenState[0].stats;

  const [inputState, setInputState] = useState(
    !token.allowance ? InputState.ENABLE : InputState.ENTERAMOUNT
  );

  let transaction : TransactionStatus | undefined;

  const [amount, setAmount] = useState("0.00");

 

  function resetInput() {
    if(inputState !==  InputState.ENABLE){
      setInputState(InputState.ENTERAMOUNT);

    }
    setAmount("0.00");
  }
  function checkInput(value: string, amount: number) {
    if (value == "") {
      setAmount("0.00");
    }
    //TODO: if not enabled or borrow modal
    if (inputState !== InputState.ENABLE ) {
      if (isNaN(Number(value))) {
        setInputState(InputState.INVALID);
      } else if (value.length < 1 || Number(value) == 0) {
        setInputState(InputState.ENTERAMOUNT);
      } else if (Math.abs(Number(value)) > amount) {
        setInputState(InputState.NOFUNDS);
      } else {
        setAmount(value);
        setInputState(InputState.CONFIRM);
      }
    }
  }

  function WalletforSupplyAndBorrow() {
    if (!props.isBorrow) {
      return (
        <Wallet>
          <p>Wallet Balance</p>
          <p>
            {formatBalance(token.balanceOf)} {token.data.underlying_symbol}
          </p>
        </Wallet>
      );
    } else {
      return (
        <Wallet>
          <p>Currently Borowing</p>
          <p>
            {formatBalance(token.borrowBalance)} {token.data.underlying_symbol}
          </p>
        </Wallet>
      );
    }
  }

  function withdrawAmount(){
   return (stats.totalBorrowLimit - stats.totalBorrowLimitUsed/0.8)/token.price/token.collateralFactor
  }

  function borrowAmount(){
    return token.price*((stats.totalBorrowLimit*0.8) - stats.totalBorrow)
   }
  function WalletForWithdrawAndRepay() {
    if (!props.isBorrow) {
      return (
        <Wallet>
          <p>Currently Supplying</p>
          <p>
            {formatBalance(token.supplyBalance)} {token.data.underlying_symbol}
            {token.data.underlying_symbol}
          </p>
        </Wallet>
      );
    } else {
      return (
        <Wallet>
          <p>Wallet Balance</p>
          <p>
            {formatBalance(token.balanceOf)} {token.data.underlying_symbol}
          </p>
        </Wallet>
      );
    }
  }
  return (
    <Container>
      <div className="title">
        <img
          style={{
            width: "26px",
            height: "26px",
          }}
          src={token.data.icon}
          alt={token.data.underlying_name}
        />
        <p
          style={{
            fontWeight: "300",
            fontSize: "18px",
            letterSpacing: "-0.03em",
            color: "white",
          }}
        >
          {token.data.underlying_name}
        </p>
      </div>
      <Tabs
        disabledTabClassName="disabled"
        selectedTabClassName="selected"
        className={"tabs"}
      >
        <TabList className={"tablist"}>
          <Tab
            className={"tab"}
            selectedClassName="tab-selected"
            onClick={resetInput}
          >
            {props.isBorrow ? "borrow" : "supply"}
          </Tab>
          <Tab
            className={"tab"}
            selectedClassName="tab-selected"
            onClick={resetInput}
          >
            {props.isBorrow ? "repay" : "withdraw"}
          </Tab>
        </TabList>
        <TabPanel>
          <div
            style={{
              display: "flex",
              marginTop: "2rem",
            }}
          />
          {/* supply | borrow */}
          <DexField
            onMax={(value) => {
              
              if (inputState != InputState.ENABLE) {

                const val = props.isBorrow ? borrowAmount() : Number(value);
                if(val > 0)
                setInputState(InputState.CONFIRM);

                else {
                  setInputState(InputState.ENTERAMOUNT);
                }
                setAmount(val.toString());
              }
            }}
            limit={props.isBorrow ? borrowAmount() : undefined}
            value={amount}
            onChange={(value) => {
              checkInput(
                value,
                props.isBorrow ? token.supplyBalance : token.balanceOf
              );
            }}
            transactionType={
              props.isBorrow ? TrasanctionType.BORROW : TrasanctionType.SUPPLY
            }
            token={token}
            placeholder={amount}
            type={token.data.underlying_name}
            balance={token.balanceOf}
          />
          {/* 1st tab */}
          <Details
            transactionType={
              props.isBorrow ? TrasanctionType.BORROW : TrasanctionType.SUPPLY
            }
            amount={Number(amount)}
            token={token}
            icon={token.data.icon}
            isBorrowing={props.isBorrow}
            borrowLimit={stats.totalBorrowLimit}
            borrowBalance={stats.totalBorrowLimitUsed}
            borrowLimitUsed={Number(
              (
                (stats.totalBorrowLimitUsed / stats.totalBorrowLimit) *
                100
              ).toFixed(2)
            )}
          />

          <ReactiveButton
          transaction={transaction}
            transactionType={
              props.isBorrow ? TrasanctionType.BORROW : TrasanctionType.SUPPLY
            }
            state={inputState}
            token={token}
            amount={amount}
          />

          {WalletforSupplyAndBorrow()}
        </TabPanel>

        {/* New Tab ================================== */}
        <TabPanel>
          <div
            style={{
              display: "flex",
              marginTop: "2rem",
            }}
          />
          <DexField
            token={token}
            value={amount}
            transactionType={
              props.isBorrow ? TrasanctionType.REPAY : TrasanctionType.WITHDRAW
            }
            limit={!props.isBorrow && withdrawAmount() < token.supplyBalance ? withdrawAmount() : undefined}
            //Withdraw and repay
            onMax={(value) => {

              if (inputState != InputState.ENABLE) {
                
                //check if we are in the withdraw state
                const val = !props.isBorrow ? (withdrawAmount() < token.supplyBalance ? withdrawAmount() : value ) : Math.min(token.balanceOf, token.borrowBalance)
               console.log(val)
                setAmount(val.toString())
                setInputState(InputState.CONFIRM);

              }
            }}
            onChange={(value) => {
              checkInput(
                value,
                props.isBorrow ? token.borrowBalance : token.supplyBalance
              );
            }}
            placeholder={amount}
            balance={props.isBorrow ? token.borrowBalance : token.supplyBalance}
          />
          {/* 2nd tab */}
          <Details

            transactionType={
              props.isBorrow ? TrasanctionType.REPAY : TrasanctionType.WITHDRAW
            }
            icon={token.data.icon}
            token={token}
            amount={Number(amount)}
            borrowLimit={stats.totalBorrowLimit}
            borrowLimitUsed={Number(
              (
                (stats.totalBorrowLimitUsed / stats.totalBorrowLimit) *
                100
              ).toFixed(2)
            )}
            borrowBalance={stats.totalBorrowLimitUsed}
            isBorrowing={props.isBorrow}
          />
          <ReactiveButton 
          transaction={transaction}
            state={inputState}
            token={token}
            amount={amount}
            transactionType={
              props.isBorrow ? TrasanctionType.REPAY : TrasanctionType.WITHDRAW
            }
          />

          {WalletForWithdrawAndRepay()}
        </TabPanel>
      </Tabs>
    </Container>
  );




};
export default LendingModal;
